import argparse
import json
import os
import subprocess
from pathlib import Path
from typing import Any, Mapping, Sequence

TEST_PATH = Path(__file__).parent
PROJECT_PATH = TEST_PATH.parent
CACHE_PATH = TEST_PATH / ".cache"
GENERATED_PATH = PROJECT_PATH / "src/generated"

COMPTO_PROGRAM_ID_JSON = CACHE_PATH / "compto_program_id.json"
#COMPTO_SO = PROJECT_PATH / "target/deploy/comptoken.so"

COMPTOKEN_MINT_JSON = CACHE_PATH / "comptoken_mint.json"

TEST_USER_ACCOUNT_JSON = CACHE_PATH / "test_user_account.json"

COMPTO_GLOBAL_DATA_ACCOUNT_JSON = CACHE_PATH / "compto_global_data_account.json"
COMPTO_INTEREST_BANK_ACCOUNT_JSON = CACHE_PATH / "compto_interest_bank_account.json"
COMPTO_UBI_BANK_ACCOUNT_JSON = CACHE_PATH / "compto_ubi_bank_account.json"

COMPTO_GENERATED_RS_FILE = GENERATED_PATH / "comptoken_generated.rs"

MINT_DECIMALS = 0  # MAGIC NUMBER ensure this remains consistent with constants.rs

class SubprocessFailedException(Exception):
    pass

class PDA(dict[str, Any]):

    def __init__(self, programId: str, *seeds: str | int | bytes) -> None:
        seeds_str = ""
        for seed in seeds:
            if isinstance(seed, str):
                seeds_str += f"string:'{seed}'"
            elif isinstance(seed, int):
                seeds_str += f"hex:'{hex(seed)}'"
            elif isinstance(seed, bytes):  # type: ignore
                seeds_str += f"pubkey:'{seed}'"
            else:
                raise TypeError(f"bad type: '{seed.__class__}'")
        super().__init__(json.loads(run(f"solana find-program-derived-address {programId} {seeds_str} --output json")))

def run(command: str | list[str], cwd: Path | None = None, env: Mapping[str, str] | None = None):
    result = subprocess.run(command, shell=True, cwd=cwd, capture_output=True, text=True, env=env)
    if result.returncode != 0:
        raise SubprocessFailedException(
            f"Failed to run command! command: {command} stdout: {result.stdout} stderr: {result.stderr}"
        )
    return result.stdout.rstrip()

def generateFiles():
    print("generating files...")
    programId = randAddress()
    # programId
    generateProgramIdFile(programId)
    # mint
    mint_address = generateMint()
    # pdas
    globalDataSeed = generateGlobalDataPDA(programId)
    interestBankSeed = generateInterestBankPDA(programId)
    UBIBankSeed = generateUBIBankPDA(programId)
    # test user
    generateTestUser()
    # rust file
    generateComptokenAddressFile(globalDataSeed, interestBankSeed, UBIBankSeed, mint_address)
    print("done generating files")

def generateTestUser():
    run(f"solana-keygen new --no-bip39-passphrase --force --silent --outfile {TEST_USER_ACCOUNT_JSON}")

def generateProgramIdFile(programId: str):
    write(COMPTO_PROGRAM_ID_JSON, json.dumps({"programId": programId}))

def generateGlobalDataPDA(programId: str) -> PDA:
    pda = PDA(programId, "Global Data")
    write(COMPTO_GLOBAL_DATA_ACCOUNT_JSON, json.dumps(pda))
    return pda

def generateInterestBankPDA(programId: str) -> PDA:
    pda = PDA(programId, "Interest Bank")
    write(COMPTO_INTEREST_BANK_ACCOUNT_JSON, json.dumps(pda))
    return pda

def generateUBIBankPDA(programId: str) -> PDA:
    pda = PDA(programId, "UBI Bank")
    write(COMPTO_UBI_BANK_ACCOUNT_JSON, json.dumps(pda))
    return pda

def generateComptokenAddressFile(globalDataSeed: PDA, interestBankSeed: PDA, UBIBankSeed: PDA, mint_address: str):

    print(f"Generating {COMPTO_GENERATED_RS_FILE}...")
    file_data = f"""\
// AUTOGENERATED DO NOT TOUCH
// generated by test/full_deploy_test.py

// A given seed and program id have a 50% chance of creating a valid PDA.
// Before building/deploying, we find the canonical seed by running 
//      `solana find-program-derived-address <program_id>`
// This is an efficiency optimization. We are using a static seed to create the PDA with no bump.
// We ensure when deploying that the program id is one that only needs the seed above and no bump.
// This is because 
//      (1) create_program_address is not safe if using a user provided bump.
//      (2) find_program_address is expensive and we want to avoid iterations.

use spl_token_2022::solana_program::{{pubkey, pubkey::Pubkey}};

pub const COMPTOKEN_MINT_ADDRESS: Pubkey = pubkey!("{mint_address}");

pub const COMPTO_GLOBAL_DATA_ACCOUNT_BUMP: u8 = {globalDataSeed["bumpSeed"]};
pub const COMPTO_INTEREST_BANK_ACCOUNT_BUMP: u8 = {interestBankSeed["bumpSeed"]};
pub const COMPTO_UBI_BANK_ACCOUNT_BUMP: u8 = {UBIBankSeed["bumpSeed"]};\
"""
    write(COMPTO_GENERATED_RS_FILE, file_data)

def generateMint() -> str:
    address = randAddress()
    file_data = f'''\
{{
    "commandName": "CreateToken",
    "commandOutput": {{
        "address": "{address}",
        "decimals": {MINT_DECIMALS},
        "transactionData": {{
            "signature": ""
        }}
    }}
}}\
'''
    write(COMPTOKEN_MINT_JSON, file_data)
    return address

def write(path: Path, data: str):
    with open(path, "w") as file:
        file.write(data)

def randAddress() -> str:
    keygen = run("solana-keygen new --no-bip39-passphrase --no-outfile")
    return keygen.split("\n")[2][8:]

def build():
    print("building...")
    run('cargo build-sbf --features "testmode"', PROJECT_PATH)
    print("done buiding")

def runTest(test: str, file: str) -> bool:
    print(f"running {test}")
    env = os.environ
    env["SBF_OUT_DIR"] = str(PROJECT_PATH / "target/deploy/")
    try:
        run(f"node {TEST_PATH / f'compto-test-client/{file}'}", env=env)
        print(f"{test} passed")
        return True
    except SubprocessFailedException as e:
        print(f"{test} failed")
        print(e)
        return False

def runTests(args: argparse.Namespace):
    print("running tests...")

    passed = 0
    skipped = 0
    for (arg, val) in args._get_kwargs():
        if val:
            passed += runTest(arg, f'test_{arg}')
        else:
            skipped += 1
    failed = len(args._get_kwargs()) - passed - skipped
    print()
    print(f"passed: {passed}    failed: {failed}    skipped: {skipped}")

def store_const_multiple(const: Any, *destinations: str):
    """Returns an `argparse.Action` class that sets multiple argument destinations (`destinations`) to `const`."""

    class store_const_multiple_action(argparse.Action):

        def __init__(self, *args, **kwargs):
            super(store_const_multiple_action, self).__init__(metavar=None, nargs=0, const=const, *args, **kwargs)

        def __call__(
            self,
            parser: argparse.ArgumentParser,
            namespace: argparse.Namespace,
            values: str | Sequence[Any] | None,
            option_string: str | None = None
        ):
            for destination in destinations:
                setattr(namespace, destination, const)

    return store_const_multiple_action

def store_true_multiple(*destinations: str):
    """Returns an `argparse.Action` class that sets multiple argument destinations (`destinations`) to `True`."""
    return store_const_multiple(True, *destinations)

def store_false_multiple(*destinations: str):
    """Returns an `argparse.Action` class that sets multiple argument destinations (`destinations`) to `True`."""
    return store_const_multiple(False, *destinations)

def parseArgs(tests: list[str]):
    parser = argparse.ArgumentParser(prog="comptoken component tests")
    for argument in tests:
        parser.add_argument(f"--no-{argument.replace('_', '-')}", action="store_false", dest=argument)
        parser.add_argument(f"--{argument.replace('_', '-')}", action="store_true", dest=argument)
    parser.add_argument("--none", action=store_false_multiple(*tests), dest="mint")

    return parser.parse_args()

if __name__ == "__main__":
    tests = [
        "mint", "initialize_comptoken_program", "create_user_data_account", "proof_submission", "get_valid_blockhashes",
        "get_owed_comptokens", "daily_distribution_event"
    ]
    args = parseArgs(tests)
    generateFiles()
    build()
    runTests(args)
